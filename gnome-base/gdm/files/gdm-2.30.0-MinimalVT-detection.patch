

--- daemon/vt_test.h	2010-04-08 02:48:35.573286911 +0200
+++ daemon/vt_test.h	2010-04-08 03:04:41.000000000 +0200
@@ -0,0 +1,9 @@
+
+/* tests if a given file is opened by a process
+   return -1 on error, 0 if unused or pid of first process found */
+
+int in_use(char* proben);
+
+/* return number of first free virtual terminal above a given number or -1 on error */
+int get_free_vt(int first);
+
--- daemon/vt_test.c	1970-01-01 01:00:00.000000000 +0100
+++ daemon/vt_test.c	2010-04-08 02:45:32.000000000 +0200
@@ -0,0 +1,75 @@
+
+#include <stdio.h>
+#include <dirent.h>
+#include <sys/stat.h>
+#include <linux/vt.h>
+#include "vt_test.h"
+
+#define debug printf
+
+
+/* tests if a given file is opened by a process
+   return -1 on error, 0 if unused or pid of first process found */
+
+int in_use(char* proben) {
+	int ret = 0;
+	struct stat probe;
+	if (stat(proben, &probe)) {
+		debug("error stat64 %s\n", proben);
+		return -1;
+	}
+
+	char* procn = "/proc";
+	struct dirent *pide;
+	DIR *proc;
+	if ((proc = opendir(procn)) == NULL) {
+		debug("error opening %s\n", procn);
+		return -1;
+	}
+		
+	while (!ret && (pide = readdir(proc))) {
+		if (pide->d_type != DT_DIR)
+			continue;
+		int pid;
+		if (!sscanf(pide->d_name, "%i", &pid))
+			continue;
+		#define FDN_MAX 50
+		char fddn[FDN_MAX];
+		snprintf(fddn, FDN_MAX, "%s/%i/fd", procn, pid);
+		DIR *fdd;
+		if ((fdd = opendir(fddn)) == NULL) {
+			debug("error opening %s\n", fddn);
+			continue;
+		}
+		struct dirent *fd;
+		while (!ret && (fd = readdir(fdd))) {
+			char fdn[FDN_MAX];
+			snprintf(fdn, FDN_MAX, "%s/%s", fddn, fd->d_name);
+			struct stat fds;
+			if (stat(fdn, &fds)) {
+				debug("error stat64 %s\n", proben);
+				continue;
+			}	
+			if (probe.st_dev == fds.st_dev && probe.st_ino == fds.st_ino) {
+				debug("found %s as fd %s of pid %i\n", proben, fdn, pid);
+				ret = pid;
+			}
+		}
+		closedir(fdd);
+	}
+	closedir(proc);
+	return ret;
+}
+
+/* return number of first free virtual terminal above a given number or -1 on error */
+int get_free_vt(int first) {
+	char vt[20];
+	if (first < MIN_NR_CONSOLES)
+		first = MIN_NR_CONSOLES;
+	for ( ; first <= MAX_NR_CONSOLES ; first++ ) {
+		snprintf(vt, 20, "/dev/tty%i", first);
+		if(!in_use(vt))
+			break;
+	}
+	return first <= MAX_NR_CONSOLES ? first : -1;
+}
+
--- daemon/Makefile.am	2010-04-08 03:27:58.000000000 +0200
+++ daemon/Makefile.am	2010-04-08 03:27:50.000000000 +0200
@@ -120,6 +120,8 @@
 	gdm-greeter-session.h		\
 	gdm-server.c			\
 	gdm-server.h			\
+	vt_test.c			\
+	vt_test.h			\
 	gdm-session.c			\
 	gdm-session.h			\
 	gdm-session-private.h		\
@@ -159,6 +161,8 @@
 	gdm-greeter-session.h		\
 	gdm-server.c			\
 	gdm-server.h			\
+	vt_test.c			\
+	vt_test.h			\
 	gdm-session.c			\
 	gdm-session.h			\
 	gdm-session-private.h		\
@@ -184,6 +188,8 @@
 	product-slave-main.c 		\
 	gdm-server.c			\
 	gdm-server.h			\
+	vt_test.c			\
+	vt_test.h			\
 	gdm-session.c			\
 	gdm-session.h			\
 	gdm-session-private.h		\
--- daemon/gdm-server.c	2010-03-29 23:42:03.000000000 +0200
+++ daemon/gdm-server.c	2010-04-08 02:53:50.000000000 +0200
@@ -44,8 +44,14 @@
 #include "gdm-common.h"
 #include "gdm-signal-handler.h"
 
+#include "gdm-settings.h"
+#include "gdm-settings-direct.h"
+#include "gdm-settings-keys.h"
 #include "gdm-server.h"
 
+#include "vt_test.h"
+
+extern char **environ;
 extern char **environ;
 
 #define GDM_SERVER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GDM_TYPE_SERVER, GdmServerPrivate))
@@ -80,6 +86,8 @@
         char    *parent_auth_file;
         char    *chosen_hostname;
 
+        char    *vt;
+        int	vt_i;
         guint    child_watch_id;
 };
 
@@ -676,7 +684,7 @@
         gboolean res;
 
         /* fork X server process */
-        res = gdm_server_spawn (server, NULL);
+        res = gdm_server_spawn (server, server->priv->vt);
 
         return res;
 }
@@ -924,9 +932,12 @@
 
 }
 
+
 static void
 gdm_server_init (GdmServer *server)
 {
+	int vt;
+        gboolean has_vt;
 
         server->priv = GDM_SERVER_GET_PRIVATE (server);
 
@@ -934,6 +945,17 @@
         server->priv->command = g_strdup (X_SERVER " -br -verbose");
         server->priv->log_dir = g_strdup (LOGDIR);
 
+	has_vt =  gdm_settings_direct_get_int (GDM_KEY_MINIMALVT, &vt);
+	if (!has_vt)
+		vt = 7;
+	if ((vt = get_free_vt(vt)) < 0) {
+		printf("can't determine free terminal, ooops\n"); 
+		server->priv->vt = g_strdup_printf ("");
+	} else {
+		printf("force server to free terminal %i\n", vt);
+		server->priv->vt = g_strdup_printf ("vt %d", vt);
+	}
+
         add_ready_handler (server);
 }
 
--- data/gdm.conf-custom.in	2010-03-29 23:42:03.000000000 +0200
+++ data/gdm.conf-custom.in	2010-04-08 02:33:27.000000000 +0200
@@ -1,6 +1,9 @@
 # GDM configuration storage
 
 [daemon]
+# sets the minimal number of the virtual terminal gdm will force Xorg to use, defaults to 7
+# Used to keep vt1..6 free for later spawned login-terminals
+MinimalVT = 7
 
 [security]
 
--- data/gdm.schemas.in.in	2010-03-29 23:42:03.000000000 +0200
+++ data/gdm.schemas.in.in	2010-04-08 02:33:27.000000000 +0200
@@ -23,6 +23,11 @@
       <default>@GDM_GROUPNAME@</default>
     </schema>
     <schema>
+      <key>daemon/MinimalVT</key>
+      <signature>i</signature>
+      <default>7</default>
+    </schema>
+    <schema>
       <key>daemon/AutomaticLoginEnable</key>
       <signature>b</signature>
       <default>false</default>
--- common/gdm-settings-keys.h	2010-03-29 23:42:03.000000000 +0200
+++ common/gdm-settings-keys.h	2010-04-04 19:29:50.000000000 +0200
@@ -27,6 +27,7 @@
 
 #define GDM_KEY_USER "daemon/User"
 #define GDM_KEY_GROUP "daemon/Group"
+#define GDM_KEY_MINIMALVT "daemon/MinimalVT"
 #define GDM_KEY_AUTO_LOGIN_ENABLE "daemon/AutomaticLoginEnable"
 #define GDM_KEY_AUTO_LOGIN_USER "daemon/AutomaticLogin"
 #define GDM_KEY_TIMED_LOGIN_ENABLE "daemon/TimedLoginEnable"
